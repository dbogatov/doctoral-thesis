\chapter{Introduction}
\thispagestyle{myheadings}

	As the organizations struggle with demands for storage and processing of their data, they increasingly turn to third parties for outsourcing capabilities.
	A number of companies including Amazon (AWS), Microsoft (Azure) and Google (GCP) offer outsourced database solutions to individuals and other businesses.
	This model is lucrative because not only do the clients pay exactly for what they use in terms of pure computational resources, but also the cloud takes care of the entire deployment process, including availability, scalability, replication, and, most importantly, security.
	The cloud business model provides resources on-demand --- from bare-bones \acrshort{vm} to database-as-a-service products.

	While the cloud providers typically have strict customer data privacy policies and even offer server-side encryption-at-rest services, the clients still have to trust the provider with their plaintext data.
	Server-side encryption-at-rest by definition requires the provider to know the encryption key to manipulate the data, even if the key is ephemeral and is not stored in the cloud permanently.
	Moreover, cloud providers in general, and customers' \acrshortpl{vm} in particular, may be vulnerable to external attacks --- from snapshot-level attacks, in which the adversary has a copy of the \acrshort{vm} memory, to more devastating persistent attacks, in which the adversary continuously monitors the \acrshort{vm} processes.

	Protecting the private information beyond cloud provider guarantees typically requires encrypting it in a way that preserves the ability to process it.
	A line of research targets securing outsourced database systems, but often achieves protection at the cost of efficiency too high for a solution to be viable for practical applications.
	In this prospectus, I will cover the constructions that are used to answer different types of database queries in the outsourced model while providing both provable security and practical efficiency guarantees.

	\section{Model}

		In this work, I consider \emph{an outsourced database system} model adapted from \cite{generic-attacks-kellaris} and \cite{epsolute}.

		\subsection{Outsourced database model}

			Similar to~\cite{epsolute}, a database is abstracted as a collection of \dataSize{} records \record{}, each with a unique identifier \recordID{}, associated with search keys \searchKey{}: \databaseDef{}.
			All records are assumed to have an identical fixed bit-length, and the search keys are elements of some domain \searchKeyDomain{}.
			A query is modeled as a predicate $\query \in \querySet: \searchKeyDomain \to \bin$.
			Evaluating a query \query{} on a database \database{} results in $\query( \database ) = \{ \record_i : \query( \searchKey_i ) = 1 \}$, all records whose search keys satisfy \query{}.

			Formally, an outsourced database system consists of two protocols between a stateful user \user{}, who owns the data, and an untrusted stateful server \server{}, to whom these data are outsourced.
			In setup protocol \protocolSetup{}, \user{} receives as input a database \databaseDef{} and \server{} may optionally output a data structure \serverDS{}.
			In query protocol \protocolQuery{}, \user{} receives a query $\query \in \querySet$, \server{} receives \serverDS{} produced in the setup protocol, and \user{} outputs the result of the query $\query( \database )$.
			Both parties may update their internal states.
			We call a system \emph{correct} if it holds with overwhelming probability over the randomness of the above runs that running \protocolSetup{} and  \protocolQuery{} on the corresponding inputs yields the correct result $\{ \record_i : \query( \searchKey_i ) = 1 \}$.

		\subsection{Security model}

			I define two types of adversaries --- a \emph{snapshot} and a \emph{persistent} adversaries.

			As the name suggests, a snapshot adversary can see a ``snapshot'' of the server's data at multiple points in time.
			One can think of such an attack as if someone steals a hard drive or accesses a backup.
			Formally, \adversary{} knows \server{} state at all stages of the protocol.

			A persistent adversary is stronger in that she monitors the server continuously.
			Therefore, she can see what snapshot adversary can plus the network traffic and the access pattern.
			Such adversary can be thought of as malicious software (virus) that runs as a background process with broad permissions.
			Formally, on top of the \server{} state, \adversary{} knows the size and content of \server{} communication and the sequence of accesses \server{} makes to its internal state at all protocol stages.

			Intuitively, one can think that encrypting records should protect the data.
			Depending on how the records are encrypted (i.e., whether the symmetric or property-preserving encryption is used), this approach can mitigate the snapshot adversary.
			Persistent adversary, however, can observe the communication size even if the traffic itself is encrypted, and can see the access pattern even if the records are protected.
			It has been shown that the knowledge of access pattern~\cite{multidimensional-range-queries, inference-attack-islam-14, leakage-abuse-attacks-cash-15, inference-attacks-naveed-15, generic-attacks-kellaris, attacks-tao-of-inference, grubbs-attacks, access-pattern-disclosure, attacks-improved-reconstruction} or communication volume~\cite{generic-attacks-kellaris, state-of-uniform, attacks-improved-reconstruction, pump-volume-attacks, volume-range-attacks} alone can enable a series of reconstruction attacks.
			Also note that both adversaries are \emph{honest-but-curios} --- they only observe and never interfere.
			Denial-of-service attacks and integrity protection are out of scope of this work.

		\subsection{Query types}

			The type of query \query{} is deliberately left abstract.
			The outsourced database system assumes that a query contains a way (a predicate) to select only the records whose search keys satisfy it.
			In this work, I consider the following types of queries.

			\paragraph*{A point query.}
				This query selects records whose key is equal to a given value.
				The domain of the point value does not have to be ordered; it can be categorical, like color names.
				The relevant \acrshort{sql} query can be

				\texttt{SELECT * FROM t1 WHERE zip = '02215'}.

			\paragraph*{A range query.}
				This query selects records whose key lies between two values from an ordered domain.
				The relevant \acrshort{sql} query can be

				\texttt{SELECT * FROM t1 WHERE age BETWEEN 18 and 65}.

			\paragraph*{A \acrshort{knn} query.}
				\acrlong{knn} query selects $k$ records whose keys are ``closest'' to a given value.
				This query type requires a definition of distance metric over the domain of search keys, for example, simple Euclidean distance.
				The relevant \acrshort{sql} query can be

				\texttt{SELECT * FROM t1 ORDER BY location <-> '(29.9691,-95.6972)' LIMIT 5}. % chktex 36
