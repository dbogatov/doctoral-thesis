\chapter{Introduction}
\thispagestyle{myheadings}

	As the organizations struggle with demands for storage and processing of their data, they increasingly turn to third parties for outsourcing capabilities.
	A number of companies including \Gls{aws}, Microsoft (Azure) and  \Gls{gcp} offer outsourced database solutions to individuals and other businesses.
	This model is lucrative because not only the clients pay exactly for what they use in terms of pure computational resources, but also the cloud takes care of the entire deployment process, including availability, scalability, replication and, most importantly, security.
	Cloud business model is to provide resources on-demand --- from bare-bones \Glspl{vm} to database-as-a-service products.

	While the cloud providers typically have strict customer data privacy policies and even offer server-side encryption-at-rest services, the clients still have to trust the provider with their plaintext data.
	Server-side encryption-at-rest by definition requires the provider to know the encryption key to manipulate the data, even if the key is ephemeral and is not stored in the cloud permanently.
	Moreover, cloud provider in general, and customer's \Gls{vm} in particular, may be vulnerable to external attacks --- from snapshot-level attacks, in which the adversary has a copy of the \Gls{vm} memory, to more devastating persistent attacks, in which the adversary continuously monitors the \Gls{vm} processes.

	Protecting the private information beyond cloud provider guarantees typically requires encrypting it in way that preserves the ability to process it.
	A line of research targets securing outsourced database systems, but often achieves protection at a cost of efficiency that is too high for a solution to be viable for practical applications.
	In this prospectus, I will cover the constructions that are used to answer different types of database queries in the outsourced model while providing both provable security and practical efficiency guarantees.

	\section{Model}

		In this work, I consider \emph{an outsourced database system} model, adapted from \cite{generic-attacks-kellaris}.
		Similar to~\cite{epsolute}, a database is abstracted as a collection of \dataSize{} records \record{}, each with a unique identifier \recordID{}, associated with search keys \searchKey{}: \databaseDef{}.
		All records are assumed to have an identical fixed bit-length, and the search keys are elements of some domain \searchKeyDomain{}.
		A query is modeled as a predicate $\query \in \querySet: \searchKeyDomain \to \bin$.
		Evaluating a query \query{} on a database \database{} results in $\query( \database ) = \{ \record_i : \query( \searchKey_i ) = 1 \}$, all records whose search keys satisfy \query{}.

		Formally, an outsourced database system consists of two protocols between a stateful user \user{}, who owns the data, and an untrusted stateful server \server{}, to whom these data are outsourced (adapted from \cite{epsolute}): % chktex 2
		\begin{description}
			\item[Setup protocol \protocolSetup{}:]
				\user{} receives as input a database \databaseDef{}; \server{} has no input.
				\server{} may optionally output a data structure \serverDS{}; \user{} has no output.

			\item[Query protocol \protocolQuery{}:]
				\user{} receives a query $\query \in \querySet$; \server{} receives \serverDS{} produced in the setup protocol.
				\user{} outputs the result of the query $\query( \database )$; \server{} has no formal output.
		\end{description}
		Both parties may update their internal states.
		We call a system \emph{correct} if it holds with overwhelming probability over the randomness of the above runs that running \protocolSetup{} and  \protocolQuery{} on the corresponding inputs yields the correct result $\{ \record_i : \query( \searchKey_i ) = 1 \}$.

		I define two types of adversaries --- a \emph{snapshot} and a \emph{persistent} adversaries.

		A snapshot adversary, as the name suggests, can see a ``snapshot'' of server's data at multiple points in time.
		One can think of such attack as if someone steals a hard drive or accesses a backup.
		Formally, \adversary{} knows \server{} state at all stages of the protocol.

		A persistent adversary is stronger in that she monitors the server continuously.
		Therefore, she can see what snapshot adversary can plus the network traffic and the access pattern.
		Such adversary can be thought of as a malicious software (virus) that runs as a background process with wide permissions.
		Formally, on top of \server{} state, \adversary{} knows the size and content of \server{} communication and the sequence of accesses \server{} makes to its internal state at all stages of the protocol.

		Intuitively, one can think that encrypting records should protect the data.
		Depending on the way the records are encrypted (i.e., whether the semantic or property-preserving encryption is used), this approach can mitigate the snapshot adversary.
		Persistent adversary, however, can observe the communications size even if the traffic itself is encrypted, and can see the access pattern even if the records are protected.
		It has been shown that the knowledge of access pattern~\cite{multidimensional-range-queries, inference-attack-islam-14, leakage-abuse-attacks-cash-15, inference-attacks-naveed-15, generic-attacks-kellaris, attacks-tao-of-inference, grubbs-attacks, access-pattern-disclosure, attacks-improved-reconstruction} or communication volume~\cite{generic-attacks-kellaris, state-of-uniform, attacks-improved-reconstruction, pump-volume-attacks, volume-range-attacks} alone can enable a series of reconstruction attacks.
		Also note that both adversaries are \emph{honest-but-curios} --- they only observe and never interfere.
		Denial-of-service attacks and integrity protection are out of scope of this work.

		The type of query \query{} is deliberately left abstract.
		The outsourced database system assumes that a query contains a way (a predicate) to select only the records whose search keys satisfy it.
		In this work I consider these types of queries.

		\paragraph*{A point query.}
			This query selects records whose key is equal to a certain value.
			The domain of the point value does not have to be ordered; it can be categorical, like color names.
			The relevant SQL query can be \texttt{SELECT * FROM t1 WHERE zip = '02215'}.

		\paragraph*{A range query.}
			This query selects records whose key lies between two values from an ordered domain.
			The relevant SQL query can be \texttt{SELECT * FROM t1 WHERE age BETWEEN 18 and 65}.

		\paragraph*{A $k$NN query.}
			$k$-nearest neighbor query selects $k$ records whose keys are ``closest'' to a certain value.
			This query type requires a definition of distance metric over the domain of search keys, for example, simple Euclidean distance.
			The relevant SQL query can be \texttt{SELECT * FROM t1 ORDER BY location <-> '(29.9691,-95.6972)' LIMIT 5}. % chktex 36

		\paragraph*{An inner-\texttt{JOIN} query.}
			An inner equi-\texttt{JOIN} query is different in that it is run on two tables and it selects all pairs of tuples where search keys of records of both tables are equal.
			A \texttt{GROUP BY} query is related to \texttt{JOIN} as a degraded version of the latter.
			The relevant SQL query can be \texttt{SELECT * FROM t1 INNER JOIN t2 ON (t1.k = t2.k) GROUP BY zip}.

	\section{Proposal}

		I propose to structure the thesis around the problem of answering the aforementioned four query types securely in a presence of snapshot and persistent adversaries.
		The thesis will include a rich background on proposed secure query processing solutions and attacks against these solutions.
		I will explain the components that are needed to construct the solutions, including symmetric encryption, property-preserving encryption, \Gls{oram} and Differential Privacy.

		During my studies, I have proposed an evaluation framework to audit the \gls{ore} schemes and secure range query solutions in a snapshot model \cite{ore-benchmark-17}, see \cref{section:range-queries-snapshot}.
		The work includes five \gls{ope} and \gls{ore} schemes and five secure range query protocols.
		I analyze the solutions under a common security framework and compare them experimentally under a common testbed.

		In the persistent adversary model, I propose a protocol to answer point and range queries while hiding both the access pattern the result size \cite{epsolute}.
		The algorithm uses \Gls{oram} to hide the access pattern and Differentially Private sanitizers to obfuscate the communication volume.
		The construction is parallelized such that the database is split among a number of \Glspl{oram} --- isolated servers executing an \Gls{oram} protocol.
		I show that his construction is not only secure in a proposed model, but also very efficient --- a typical query completes in less than second.

		For the \knn{} queries, I propose a solution in a snapshot model, similar to \gls{ope}.
		The idea is to encrypt an input in a way that the distance comparison between two pairs of values is preserved.
		That is, if $x$ to $y$ was longer than $y$ to $z$, the relation will hold for the encrypted values.
		I will then verify the utility of the solution by running typical \knn{} applications over the encrypted inputs --- similarity search and location-based queries.

		Finally, I propose to process \texttt{JOIN} queries obliviously, in a presence of persistent adversary, by partitioning the input and processing it inside a secure enclave one partition at a time.
		The idea is to
		\begin{enumerate*}[label=(\roman*)] % chktex 36
			\item create an index over join keys,
			\item add noise using Differential Privacy,
			\item partition the index by join keys in way that the partition fits in the enclave,
			\item and do the cross join within partition inside the enclave.
		\end{enumerate*}

	Following are extended descriptions of these proposed solutions.
