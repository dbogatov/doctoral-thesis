\chapter{Proposal}
\thispagestyle{myheadings}

	\section{Introduction and Background}

		As the organizations struggle with demands for storage and processing of their data, they increasingly turn to third parties for outsourcing capabilities.
		A number of companies including Amazon (AWS), Microsoft (Azure) and Google (GCP) offer outsourced database solutions to individuals and other businesses.
		This model is lucrative because not only the clients pay exactly for what they use in terms of pure computational resources, but also the cloud takes care of the entire deployment process, including availability, scalability, replication and, most importantly, security.
		Cloud business model is to provide resources on-demand --- from bare-bones \acrshort{vm} to database-as-a-service products.

		While the cloud providers typically have strict customer data privacy policies and even offer server-side encryption-at-rest services, the clients still have to trust the provider with their plaintext data.
		Server-side encryption-at-rest by definition requires the provider to know the encryption key to manipulate the data, even if the key is ephemeral and is not stored in the cloud permanently.
		Moreover, cloud provider in general, and customer's \acrshort{vm} in particular, may be vulnerable to external attacks --- from snapshot-level attacks, in which the adversary has a copy of the \acrshort{vm} memory, to more devastating persistent attacks, in which the adversary continuously monitors the \acrshort{vm} processes.

		Protecting the private information beyond cloud provider guarantees typically requires encrypting it in a way that preserves the ability to process it.
		A line of research targets securing outsourced database systems, but often achieves protection at a cost of efficiency that is too high for a solution to be viable for practical applications.
		In this prospectus, I will cover the constructions that are used to answer different types of database queries in the outsourced model while providing both provable security and practical efficiency guarantees.

		\subsection{Model}\label{proposal:intro:model}

			In this work, I consider \emph{an outsourced database system} model, adapted from \cite{generic-attacks-kellaris} and \cite{epsolute}.

			\subsubsection{Outsourced database model}

				Similar to~\cite{epsolute}, a database is abstracted as a collection of \dataSize{} records \record{}, each with a unique identifier \recordID{}, associated with search keys \searchKey{}: \databaseDef{}.
				All records are assumed to have an identical fixed bit-length, and the search keys are elements of some domain \searchKeyDomain{}.
				A query is modeled as a predicate $\query \in \querySet: \searchKeyDomain \to \bin$.
				Evaluating a query \query{} on a database \database{} results in $\query( \database ) = \{ \record_i : \query( \searchKey_i ) = 1 \}$, all records whose search keys satisfy \query{}.

				Formally, an outsourced database system consists of two protocols between a stateful user \user{}, who owns the data, and an untrusted stateful server \server{}, to whom these data are outsourced.
				In setup protocol \protocolSetup{}, \user{} receives as input a database \databaseDef{} and \server{} may optionally output a data structure \serverDS{}.
				In query protocol \protocolQuery{}, \user{} receives a query $\query \in \querySet$, \server{} receives \serverDS{} produced in the setup protocol, and \user{} outputs the result of the query $\query( \database )$.
				Both parties may update their internal states.
				We call a system \emph{correct} if it holds with overwhelming probability over the randomness of the above runs that running \protocolSetup{} and  \protocolQuery{} on the corresponding inputs yields the correct result $\{ \record_i : \query( \searchKey_i ) = 1 \}$.

			\subsubsection{Security model}

				I define two types of adversaries --- a \emph{snapshot} and a \emph{persistent} adversaries.

				A snapshot adversary, as the name suggests, can see a ``snapshot'' of server's data at multiple points in time.
				One can think of such attack as if someone steals a hard drive or accesses a backup.
				Formally, \adversary{} knows \server{} state at all stages of the protocol.

				A persistent adversary is stronger in that she monitors the server continuously.
				Therefore, she can see what snapshot adversary can plus the network traffic and the access pattern.
				Such adversary can be thought of as a malicious software (virus) that runs as a background process with wide permissions.
				Formally, on top of \server{} state, \adversary{} knows the size and content of \server{} communication and the sequence of accesses \server{} makes to its internal state at all stages of the protocol.

				Intuitively, one can think that encrypting records should protect the data.
				Depending on the way the records are encrypted (i.e., whether the semantic or property-preserving encryption is used), this approach can mitigate the snapshot adversary.
				Persistent adversary, however, can observe the communications size even if the traffic itself is encrypted, and can see the access pattern even if the records are protected.
				It has been shown that the knowledge of access pattern~\cite{multidimensional-range-queries, inference-attack-islam-14, leakage-abuse-attacks-cash-15, inference-attacks-naveed-15, generic-attacks-kellaris, attacks-tao-of-inference, grubbs-attacks, access-pattern-disclosure, attacks-improved-reconstruction} or communication volume~\cite{generic-attacks-kellaris, state-of-uniform, attacks-improved-reconstruction, pump-volume-attacks, volume-range-attacks} alone can enable a series of reconstruction attacks.
				Also note that both adversaries are \emph{honest-but-curios} --- they only observe and never interfere.
				Denial-of-service attacks and integrity protection are out of scope of this work.

			\subsubsection{Query types}

				The type of query \query{} is deliberately left abstract.
				The outsourced database system assumes that a query contains a way (a predicate) to select only the records whose search keys satisfy it.
				In this work I consider these types of queries.

				\paragraph*{A point query.}
					This query selects records whose key is equal to a certain value.
					The domain of the point value does not have to be ordered; it can be categorical, like color names.
					The relevant SQL query can be

					\texttt{SELECT * FROM t1 WHERE zip = '02215'}.

				\paragraph*{A range query.}
					This query selects records whose key lies between two values from an ordered domain.
					The relevant SQL query can be

					\texttt{SELECT * FROM t1 WHERE age BETWEEN 18 and 65}.

				\paragraph*{A \knn{} query.}
					$k$-nearest neighbor query selects $k$ records whose keys are ``closest'' to a certain value.
					This query type requires a definition of distance metric over the domain of search keys, for example, simple Euclidean distance.
					The relevant SQL query can be

					\texttt{SELECT * FROM t1 ORDER BY location <-> '(29.9691,-95.6972)' LIMIT 5}. % chktex 36

		\subsection{Proposal}

			I propose to structure the thesis around the problem of answering the aforementioned three query types securely in the presence of snapshot or persistent adversaries.
			The thesis will include a rich background on proposed secure query processing solutions and attacks against these solutions.
			I will explain the components that are needed to construct the solutions, including symmetric encryption, property-preserving encryption, \acrlong{oram} and Differential Privacy.

	\section{Range queries in a snapshot model}

		\subsection{Problem}

			There are a plenty of works offering range query solutions in a snapshot adversary model.
			Some authors propose a new \acrfull{ore} scheme to be used inside an existing range query index, see \cite{bclo-ope,clww-ore,lewi-wu-ore,cloz-ore,fh-ope}.
			Others suggest full client-server protocols with different security guarantees, see \cite{florian-protocol,pope,practical-ore}.

			Instead of adding another solution to the mix, we developed a robust evaluation framework to compare and audit different \acrshort{ore} schemes and range query protocols \cite{ore-benchmark-17}.
			We have noticed that all proposed solutions offer their own formal protocol, security definition (which they obliviously satisfy), and even performance metrics.
			Moreover, only a few of these algorithms have ready-to-use open-sourced code.
			More often, the implementation is a prototype (or does not even exist), rendering experiments non-reproducible.

		\subsection{Solution}

			Our work addresses these shortcomings.
			We proposed a common framework where all analyzed solutions follow the same formal protocol, a variant of outsourced database from \cref{proposal:intro:model}.
			The schemes and protocols are also tested against the same security definition, a variant of simulation-based security game where simulator has a leakage function that is different for each solution.
			Lastly, all protocols are implemented in the same language and runtime, and are using the same cryptographic primitive implementations.

			We have paid extra attention to how we quantify the performance.
			Published works typically claim that they have implemented the algorithm in some language and ran it on a server many times measuring the wall-clock time.
			Such metric is deeply flawed since it only measures just that --- the wall-clock time it took for a particular machine to execute a particular code that references particular implementations of primitives and makes (or even does not make) \IO{} requests to particular hardware.
			What we offer is a metric that drops all these ``particulars'' (i.e., dependencies) from the protocol execution.
			On top of having all solutions implemented in the same language and using same primitives, instead of measuring the time we count the number fo times an \acrshort{ore} scheme makes use of a primitive and a protocol makes an \IO{} request.
			This metric is much more demonstrative: one can always get a wall-clock time estimate given these counts and the specs of the hardware.
			Moreover, we can analyze these counts theoretically from the pseudocode and then verify them practically after running the code.

		\subsection{Results}

			In our work we apply the framework to ten range query solutions.
			Five protocols are built with an \acrfull{ore} scheme coupled with a \BPlus{} tree.
			In \protocolSetup{}, \client{} encrypts all search keys with the \acrshort{ore} scheme, constructs a \BPlus{} tree from the ciphertexts and uploads to \server{}.
			In \protocolQuery{}, \client{} sends encrypted query endpoints and \server{} follows standard \BPlus{} traversal.
			Such protocol leaks the total order of the records plus the leakage of the underlying \acrshort{ore} scheme.

			We also analyzed dedicated range query protocols from \cite{florian-protocol,pope,practical-range-search} and two more baselines.
			Baselines are chosen at the extremes of performance / security spectrum --- a plaintext \BPlus{} tree and a \BPlus{} tree in \acrshort{oram}.
			Intuitively, all solutions should lie between the baselines in both performance and security, but we show that at least performance-wise it is not the case.

			Please see \cref{table:ore} and \cref{table:range} in \cref{appendix:ore-results} for the analytical results for each solution, and \cite{ore-benchmark-17} for experimental results.
