\chapter{Range queries in a snapshot model}\label{section:range-queries-snapshot}
\thispagestyle{myheadings}

	\section{Order-revealing encryption}

		One of the ways to run a range query in a presence of a snapshot adversary is to use a conventional database range index, such as \BPlus{} tree~\cite{b-tree}, and encrypt the values in the index in a way that preserves their comparison result.
		This is exactly what \gls{ope} does.
		\gls{ope} is a scheme, a tuple of algorithms \algo{OPE.KeyGen}, \algo{OPE.Enc} and \algo{OPE.Dec}, that generate a kay, encrypt and decrypt a number respectively with a property that if $x$ was smaller, greater or equal to $y$, then their respective ciphertexts will maintain the relation.
		\gls{ore} works similarly except that the ciphertexts are not necessarily numbers and a comparison is an explicit algorithm \algo{ORE.Cmp} over hte ciphertexts.
		Formally, \gls{ope} is a specific \gls{ore} where ciphertexts are numbers and comparison is trivial, therefore, in this work I will only refer to \gls{ore}.

		Security of an \gls{ore} scheme is typically defined as via security game and a leakage profile \cite{practical-ore}.
		The scheme is defined secure with a leakage \leakage{} if there exists a simulator that can use the leakage function and can generate output indistinguishable from the one generated by the real scheme \cite{ore-benchmark-17}.
		The leakage function, ranging from as much as half of the bits of input to as little as an equality pattern of the most-significant differing bit of two inputs, is the defining security level of a scheme.

		In the comparative evaluation work \cite{ore-benchmark-17}, I choose five \gls{ore} scheme and analyze them under common framework.
		Below I concisely describe the schemes and give a summary of my finding in \cref{table:ore}.

		\paragraph*{\cite{bclo-ope}} has in its core the natural connection between a random order-preserving function and the \gls{hg}.
		The encryption algorithm is simple: split the domain into parts according to a sample from \gls{hg}, and split the range recursively and stop when the domain has one element.
		To decrypt, do the same ``path'' of splitting using the same randomness.
		The leakage if this scheme is approximately the square root of the domain, or half of the input bits.

		\paragraph*{\cite{practical-ore}} splits the inputs into $n$ sub-strings, starting with the most significant bits.
		The substring is then supplied to a keyed \gls{prf} and added to the next less significant bit.
		The comparison can then go over the two lists in-order and exit when one element is greater than the other by one.
		Naturally, the scheme leaks the location of the first differing bit.

		\paragraph*{\cite{lewi-wu-ore}} builds on \cite{practical-ore} but encrypts the input block-wise.
		For each block, left and right ciphertexts get generated, and the comparison is defined for the left part of one and the right part of the other ciphertext.
		Inside the block the bits are permuted such that one side has all permutations encoded and the other one has the correct comparison.
		This scheme reveals the location of the first differing block, but hides the differing bit inside it.

		\paragraph*{\cite{adam-ore-v2}} also builds on \cite{practical-ore} but permutes the list of \gls{prf} outputs.
		\textcite{adam-ore-v2} observe that knowing the order is not necessary as one can compare each element of one list with every element of the other.
		Adversary can then count how many elements two lists have in common, and to eliminate this leakage, \textcite{adam-ore-v2} introduce a \gls{pph}.
		\gls{pph} only exposes a single predicate, in this case, $y \overset{?}{=} x + 1$, whether the difference of two values is one.
		This scheme by design hides the location of differing bit and  only reveals the quality pattern --- whether $m_2$ differs from $m_1$ before $m_3$ does.

		\paragraph*{\cite{fh-ope}} is different in that it is stateful.
		Its private state is a binary tree where the node's value is the plaintext and node's position in a tree is the ciphertext.
		While encryption and decryption is a natural binary tree operation, comparison is more involved.
		One needs to know the boundaries of the ciphertext, the maximum and minimum ciphertext values, and then the comparison is an operation on ranges.
		While the scheme does not leak anything about a particular ciphertext itself, it reveals the insertion order via tree structure, and the statefulness requirement makes it harder to use the scheme in practice.

	\section{Secure range query protocols}

		I include in the benchmark two baseline approaches --- a \BPlus{} tree with \gls{ore} and a \BPlus{} tree in \gls{oram}.
		The security of the former construction is that fo the underlying \gls{ore}, while the security of \gls{oram} solution is absolute in the snapshot setting since the \gls{oram} stores its records symmetrically encrypted.
		Between these baselines I add three dedicated range query solutions with varying efficiency and security, see \cref{table:range}.

		\paragraph*{\cite{florian-protocol}} proposes to maintain a circular array of symmetrically encrypted ciphertexts in order.
		To insert, the array is rotated on a uniformly sampled value to hide the locations of the smallest and largest elements.
		To search, the client interactively runs a binary search, requesting an element, decrypting it and deciding whether go left or right.
		While the security of this solution is superior to \BPlus{} tree with \gls{ore}, it steal leaks total order of the elements and requires full array rotation each insertion.

		\paragraph*{\cite{pope}} makes an opposite trade off in efficiency to \cite{florian-protocol} --- it favors many insertions over few queries.
		\cite{pope} maintains a variant of a buffer tree, where insertion always lands an element in the root and allows lazy sorting later.
		To answer a query, the client interacts with the server to sort the buffers and split them into tree nodes.
		Once the three is structured, answering a query amounts to returning all ciphertexts between two endpoint leaves.
		\cite{pope} performance and security is different before the first query (cold) and after (warm).
		Cold unsorted buffer leaks nothing to the snapshot adversary, while warm structured tree reveals partial order.

		\paragraph*{\cite{practical-range-search}} uses \gls{sse} scheme and maps inputs to the ranges in which they lie.
		\gls{sse} scheme is an interactive protocol that lets the client query the document by keywords.
		\cite{practical-range-search} constructs a binary tree where each leaf is associated with one record and each intermediate node with a range so that its children are all in that range.
		Upon query, the client compute a cover --- a set of nodes that perfectly cover the requested range, and \gls{sse} scheme returns the records.
		The security of this scheme is that of the underlying \gls{sse}.

	\section{Analysis}

		For each of the \gls{ore} schemes I identify how many times it uses which cryptographic or expensive algebraic primitives, such as \gls{prg} or samplers, its ciphertext or state size and, its leakage profile.
		I deliberately do not account wall-clock execution time as this value is highly dependent on hardware and primitive implementations and is, therefore, not representative.

		For the range query protocols I concentrate on communication efficiency and \IO{} complexity.
		In terms communication I measure both the number fo messages exchanged and their size.
		For the \IO{} complexity I count how many times a block is read or written on a secondary storage, and the measurements are adjusted for different cache policies.

		\input{figures/fig-ore}

		I refer to the original work~\cite{ore-benchmark-17} for detailed results, including tables and plots.
		See \cref{figure:ore}, one of the result plots, which demonstrates one of the non-trivial findings that \gls{oram} solution is far not the slowest in the number of \IO{} requests, despite being the most secure option.
