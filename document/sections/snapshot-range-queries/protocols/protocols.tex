\section{\texorpdfstring{\acrshort{ope}}{OPE} and \texorpdfstring{\acrshort{ore}}{ORE} Schemes}

	An \acrlong{ore} scheme is a triple of polynomial\hyp{}time algorithms $\setup$, $\encrypt$ and $\compare$.
	$\setup$ generates a key of parameterized length (the $\lambda$ parameter).
	$\encrypt$ takes a numerical input (as a bit string) and produces a ciphertext.
	$\compare$ takes two ciphertexts generated by the scheme and outputs whether the first plaintext was strictly less than the second.
	Note that being able to check this condition is enough to apply all other comparison operators ($<$, $\le$, $=$, $\ge$, $>$).
	Also note that an \acrshort{ore} scheme does not include a decryption algorithm, because one can simply append a symmetric encryption of the plaintext to the produced ciphertext and use it for decryption.\footnote{
		\emph{Given the secret key}, it is possible to decrypt a ciphertext by doing binary search on the plaintext domain: encrypting known values and comparing them against the target ciphertext, until the target plaintext is found.
		However, this would require $\bigO{\log{|\domain|}}$ encryption and comparison operations.
	}
	An \acrfull{ope} scheme is a particular case of an \acrshort{ore} scheme where ciphertexts are numerical and thus $\compare$ routine is trivial (the numerical order of ciphertexts is the same as underlying plaintexts).
	\acrshort{ope} may optionally include a decryption algorithm, since appending a symmetric ciphertext is no longer possible.

	Both \acrshort{ope} and \acrshort{ore} schemes by definition allow to totally order the ciphertexts.
	This is their inherent leakage (by design) and all the \acrshort{ope} / \acrshort{ore} security definitions account for this and possibly additional leakage.

	We proceed by describing and analyzing the \acrshort{ope} / \acrshort{ore} schemes we have benchmarked.
	All plaintexts are assumed to be 32-bit signed integers, or $n$-bit inputs in complexity analysis.
	\acrshort{ope} ciphertexts are assumed to be 64-bit signed integers.

	From here, we will use the term \acrshort{ore} to refer to both \acrshort{ope} and \acrshort{ore}, unless explicitly stated otherwise.
	Each scheme has its own subsection where the first part is the construction overview followed by security discussion, and the second part is our theoretical and experimental analysis.

	\input{sections/snapshot-range-queries/protocols/bclo}

	\input{sections/snapshot-range-queries/protocols/clww}

	\input{sections/snapshot-range-queries/protocols/lewi-wu}

	\input{sections/snapshot-range-queries/protocols/cloz}

	\input{sections/snapshot-range-queries/protocols/fh-ope}

	\input{figures/tbl-primitives-theory}

\section{Secure Range Query Protocols}

	We proceed by describing and analyzing the range query protocols we have chosen.
	For the purpose of this paper, a secure range-query protocol is defined as a client-server communication involving construction and search stages.
	Communication occurs between a client, who owns some sensitive data, and an honest server, who securely stores it.
	In construction stage, a client sends the server the encrypted datapoints (index-value tuples) and the server stores them in some internal data structure.
	In search stage, a client asks the server for a range (usually specifying it with encrypted endpoints) and the server returns a set of encrypted records matching the query.
	Note that the server may interact with the client during both stages (e.g.\ ask the client to sort a small list of ciphertexts).
	Also note that we do not allow batch insertions as it would limit the use cases (e.g.\ client may require interactive one-by-one insertions).

	The first protocol is a family of constructions where a data structure ({\BPlus} tree in this case) uses \acrshort{ore} schemes internally.
	Then, we present alternative solutions with varying performance and security profiles, not relying on \acrshort{ore}.
	Finally, we introduce two baseline solutions we will use in the benchmark --- one that achieves the best performance and the other that achieves the maximal security.

	\input{sections/snapshot-range-queries/protocols/b-plus-tree}

	\input{sections/snapshot-range-queries/protocols/kerschbaum}

	\input{sections/snapshot-range-queries/protocols/pope}

	\input{sections/snapshot-range-queries/protocols/logarithmic-brc}

	\input{sections/snapshot-range-queries/protocols/baseline}

	\input{figures/tbl-protocols-theory}
