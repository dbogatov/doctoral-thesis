\subsection{CLWW \acrshort{ore}}\label{section:range-snapshot:clww}

	The \acrshort{ore} scheme by \textcite{clww-ore}, which authors call ``Practical ORE'', is the first efficient \acrshort{ore} implementation based on \acrshortpl{prf}.

	On encryption, the plaintext is split into $n$ values in the following way.
	For each bit, a value is this bit concatenated with all more significant bits.
	This value is given to a keyed \acrshort{prf} and the result is numerically added to the next less significant bit.
	This resulting list of $n$ elements is the ciphertext.

	The comparison routine traverses two lists in-order looking for the case when one value is greater than the other by exactly one, revealing location and value of the first differing bit.
	If no such index exists, the plaintexts are equal.

	\subsubsection{Security}
		A generic \acrshort{ore} security definition was introduced along with the scheme \cite{clww-ore}.
		\acrshort{ore} leakage is more clearly quantified than in \acrshort{ope}.
		The definition says that the scheme is secure with a leakage $\leak(\cdot)$ if there exists an algorithm (simulator) that has access to the leakage function and can generate output indistinguishable from the one generated by the real scheme.
		This scheme satisfies \acrshort{ore} security definition with the leakage $\leak(\cdot)$ of the location and value of the first differing bit of every pair of plaintexts.
		Note that the most significant differing bit also leaks the approximate distance between two values.

	\subsubsection{Analysis and implementation challenges}

		On encryption the algorithm makes $n$ calls to \acrshort{prf} and the comparison procedure does not use any cryptographic primitives.
		Ciphertext is a list of length $n$, where each element is an output of a \acrshort{prf} modulo 3.
		The authors claim that the ciphertext's size is $n \log_2 3$, just $1.6$ times larger than the plaintext's size.
		While this may be true for large enough $n$ if ternary encoding is used, we found that in practice the ciphertext size is still $2n$.
		$1.6 n$ for 32-bit words is $51.2$ bits, which will have to occupy one 64-bit word, or two 32-bit words, therefore resulting in $2n$ anyway.
