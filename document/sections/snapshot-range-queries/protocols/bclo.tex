\subsection{BCLO OPE}

	The OPE scheme by \textcite{bclo-ope} was the first OPE scheme that provided formal security guarantees and was used in one of the first database systems that executes queries over encrypted data (CryptDB \cite{crypt-db}).
 	The core principle of their construction is the natural connection between a random order-preserving function and the hypergeometric probability distribution.

	The encryption algorithm works by splitting the domain into two parts according to a value sampled from the hypergeometric distribution ($\hg$) routine, and splitting the range in half recursively.
	When the domain size contains a single element, the corresponding ciphertext is sampled uniformly from the current range.

	All pseudo-random decisions are made by an internal PRG ($\tapegen$ in \cite{bclo-ope}).
	This way not only the algorithm is deterministic, but also decryption is possible.
	The decryption procedure takes the same ``path'' of splitting domain and range, and when the domain size reaches one, the only value left is the original plaintext.

	\subsubsection{Security}
		This scheme is POPF-CCA secure \cite{bclo-ope}, meaning that it is as secure as the underlying ideal object --- randomly sampled order-preserving function from a certain domain to a certain range.
		For practical values of the parameters, \textcite{ope-leakage} showed that the distance between the plaintexts can be approximated to an accuracy of about the square root of the domain size.
		In other words, approximately, half of the bits (the most significant) are leaked.
		\textcite{leakage-abuse-grubs-2017} showed that this leakage allows to almost entirely decrypt the ciphertexts (given auxiliary data with a similar distribution) and encrypting strings (rather than numbers) with this scheme is especially dangerous (see \cref{section:range-snapshot:variable-inputs}).

	\subsubsection{Analysis and implementation challenges}

		Efficient sampling from the hypergeometric distribution is a challenge by itself.
		Authors suggest using a randomized yet exact (not approximate) Fortran algorithm by \textcite{hg-sampler}.
		It should be noted that the algorithm relies on infinite precision floating-point numbers, which most regular frameworks do not have.
		The security consequences of finite precision computations is actually an open question.
		The complexity of this randomized algorithm is hard to analyze; however, we empirically verified that its running time is no worse than linear in the input bit length.
		The authors also suggest a different algorithm for smaller inputs \cite{hg-sampler-small}.

		On average, encryption and decryption algorithms make $n$ calls to $\hg$, which in turn consumes entropy generated by the internal PRG\@.
		The entropy, and thus the number of calls to PRG, needed for one $\hg$ run is hard to analyze theoretically.
		However, we derived this number experimentally (see \cref{section:range-snapshot:evaluation}).

		BCLO has been implemented in numerous languages and has been deployed in a number of secure systems.
		We add {\Csharp} implementation to the list, and recommend using a library that supports infinite precision floating-point numbers when building the hypergeometric sampler.
